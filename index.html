<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Tsukuyumi Board Generator</title>
  <link rel="icon" href="icons/tsukuyumi.png">
  
  <link rel="stylesheet" href="bootstrap.min.css">
</head>
<body>
  
  <main class="container">
    <form action="#" id="controls">
      <div class="row">
        <div class="col-md-6 mt-2 mb-2">
          <h4>Number of players</h4>
          <input type="radio" class="btn-check" name="tiles" id="players-2" autocomplete="off" value="10">
          <label class="btn btn-outline-secondary btn-lg" for="players-2">2p</label>

          <input type="radio" class="btn-check" name="tiles" id="players-3" autocomplete="off" value="21">
          <label class="btn btn-outline-secondary btn-lg" for="players-3">3p</label>

          <input type="radio" class="btn-check" name="tiles" id="players-4" autocomplete="off" value="28" checked>
          <label class="btn btn-outline-secondary btn-lg" for="players-4">4p</label>

          <input type="radio" class="btn-check" name="tiles" id="players-5" autocomplete="off" value="35">
          <label class="btn btn-outline-secondary btn-lg" for="players-5">5p</label>

          <input type="radio" class="btn-check" name="tiles" id="players-6" autocomplete="off" value="42">
          <label class="btn btn-outline-secondary btn-lg" for="players-6">6p</label>
        </div>
        <div class="col-md-6 mt-2 mb-2">
          <h4>Chaos level</h4>
          <input type="radio" class="btn-check" name="chaos" id="chaos-1" autocomplete="off" value="1">
          <label class="btn btn-outline-secondary btn-lg" for="chaos-1">None</label>

          <input type="radio" class="btn-check" name="chaos" id="chaos-2" autocomplete="off" value="0.8" checked>
          <label class="btn btn-outline-secondary btn-lg" for="chaos-2">Low</label>

          <input type="radio" class="btn-check" name="chaos" id="chaos-3" autocomplete="off" value="0.6">
          <label class="btn btn-outline-secondary btn-lg" for="chaos-3">Mid</label>

          <input type="radio" class="btn-check" name="chaos" id="chaos-4" autocomplete="off" value="0.3">
          <label class="btn btn-outline-secondary btn-lg" for="chaos-4">High</label>
        </div>
        <div class="col-md-6 mt-2 mb-2">
          <button class="btn btn-primary btn-lg" type="submit">Generate</button>
        </div>
      </div>
    </form>

    <div id="grid" style="height:1000px; width:100%"></div>
  </main>

  <script src="honeycomb.min.js"></script>
  <script src="svg.min.js"></script>
  
  <script>
    const form = document.getElementById('controls');
    form.addEventListener('submit', function (event) {
      event.preventDefault();
      generateGrid();
    });
    
    generateGrid();
    
    function generateGrid() {
      // Get params from form
      const formData = new FormData(form);

      const tileCount = formData.get('tiles');
      const tileProbability = formData.get('chaos');

      // Initialize board with moon tiles
      const tiles = [{
        q: 0,
        r: 0,
        s: 0,
        type: 'moon',
      }];

      tiles.push(...ring(1).map(tile => {
        tile.type = 'moon';

        return tile;
      }));

      // Extend board randomly
      let tilesUsed = 0;
      const availableTiles = getAvailableTiles();

      while(tilesUsed < tileCount) {
        for (let r = 2; r <= 8; r++){
          ring(r).forEach(tile => {
            if (tilesUsed < tileCount && isContiguous(tile, tiles) && Math.random() < tileProbability){
              tilesUsed++;
              const properties = availableTiles.pop();
  
              tile.type = properties.type;
              tile.blockades = properties.blockades;
              tile.icon = properties.icon;
              tile.conquestValue = properties.conquestValue;
              tiles.push(tile);
            }
          })
        }
      }
      
      // Render board
      renderGrid(tiles);
    }

    // Get the set of tiles exactly `radius` distance away from the center
    function ring(radius) {
      const tiles = [];
      for (let q = -radius; q <= radius; q++){
        for (let r = -radius; r <= radius; r++){
          const s = -q - r;
          
          if (Math.max(Math.abs(q), Math.abs(r), Math.abs(s)) == radius){
            tiles.push({
              q: q,
              r: r,
              s: -q -r,
            });
          }
        }
      }

      return tiles;
    }

    // Is the tile contiguous to the board?
    function isContiguous(tile, tileList) {
      return neighbors(tile).filter(neighbor => tileList.filter(x => tileEquals(x, neighbor)).length > 0).length > 0;
    }

    // Get the set of neighbor coordinates for a tile
    function neighbors(tile) {
      return [
        shift(tile,  1, -1,  0),
        shift(tile, -1,  1,  0),
        shift(tile,  0,  1, -1),
        shift(tile,  0, -1,  1),
        shift(tile, -1,  0,  1),
        shift(tile,  1,  0, -1),
      ];
    }

    // Shift the coordinates of a tile
    function shift(tile, q, r, s) {
      return {
        q: tile.q + q,
        r: tile.r + r,
        s: tile.s + s,
      };
    }

    // Equality by coordinates
    function tileEquals(a, b) {
      return a.q == b.q && a.r == b.r && a.s == b.s;
    }

    // Render using svg.js
    function renderGrid(tiles) {
      // Define constants
      const iconSize = 40;
      const hexSize = 50;

      // Initialize canvas
      document.getElementById('grid').innerHTML = '';
      const draw = SVG().addTo('#grid').size('100%', '100%');
      const canvasWidth = draw.node.clientWidth;
      const canvasHeight = draw.node.clientHeight;

      // Initialize grid
      const Hex = Honeycomb.extendHex({ size: hexSize });
      const Grid = Honeycomb.defineGrid(Hex);    
      
      // Prepare symbols for svg
      const corners = Hex().corners();
      const blockadePivot = Hex().center();
      const blockadeCorners = [
        corners[0],
        intermediatePoint(corners[0], blockadePivot, 0.2),
        intermediatePoint(corners[1], blockadePivot, 0.2),
        corners[1],
      ];

      const blockades = [0,1,2,3,4,5].map(i =>
        draw.symbol()
          .polygon(blockadeCorners.map(({ x, y }) => `${x},${y}`).join(' '))
          .fill({color: '#c00', opacity: 0.8})
          .rotate(60*i, blockadePivot.x, blockadePivot.y)
          .translate(canvasWidth/2, canvasHeight/2)
      );
      
      const hexSymbol = draw.symbol()
        .polygon(corners.map(({ x, y }) => `${x},${y}`).join(' '))
        .stroke({ width: 1, color: '#000' })
        .translate(canvasWidth/2, canvasHeight/2);

      const icons = {
        radioactive: draw.symbol().image('icons/radioactive.png').translate(canvasWidth/2, canvasHeight/2).size(iconSize, iconSize),
        unstable: draw.symbol().image('icons/unstable.png').translate(canvasWidth/2, canvasHeight/2).size(iconSize, iconSize),
        tsukuyumi: draw.symbol().image('icons/tsukuyumi.png').translate(canvasWidth/2, canvasHeight/2).size(iconSize, iconSize),
        toxic: draw.symbol().image('icons/toxic.png').translate(canvasWidth/2, canvasHeight/2).size(iconSize, iconSize),
      };

      // Draw tiles
      Grid(tiles).forEach(hex => {
          const { x, y } = hex.toPoint()

          draw.use(hexSymbol).translate(x, y).fill(getFillColor(hex.type));
          if (hex.blockades) {
            const rotation = Math.floor(Math.random()*6);
            hex.blockades.forEach(i => draw.use(blockades[(i + rotation) % 6]).translate(x, y))
          }

          if (hex.icon) {
            draw.use(icons[hex.icon]).translate(x + hex.width()/2 - iconSize/2, y + hex.height()/2 - iconSize/2);
          }

          if (hex.conquestValue) {
            const text = draw.text(hex.conquestValue)
              .font({
                family: 'Helvetica',
                size: 20,
                weight: 'bold',
              });

              text.move(x + hex.width()/2 - text.length()/2 + canvasWidth/2, y + hex.height()/2 - 9 + canvasHeight/2);
          }
      });

      function getFillColor(type) {
        const colors = {
          blank: '#e0e0e0',
          moon: '#b53ab1',
          fertile: '#00ba5d',
          mountain: '#888',
          riverlands: '#82e2ed',
        }; 

        return colors[type];
      }

      function intermediatePoint(source, dest, t) {
        return {
          x: source.x * (1-t) + dest.x * t,
          y: source.y * (1-t) + dest.y * t,
        };
      }
    }

    // List of available tiles taken from the game
    function getAvailableTiles() {
      const tiles = [];

      addTile(9, 'blank', []);
      addTile(8, 'blank', [0]);
      addTile(3, 'blank', [0,2]);
      addTile(1, 'blank', [0,3]);
      addTile(4, 'blank', [0,1,3]);
      addTile(1, 'blank', [], 'radioactive');
      addTile(1, 'blank', [0], 'radioactive');
      addTile(1, 'blank', [0,2], 'radioactive');
      addTile(3, 'blank', [], 'unstable');
      addTile(1, 'blank', [0], 'unstable');
      addTile(2, 'blank', [], 'tsukuyumi');
      addTile(2, 'blank', [], 'toxic');
      addTile(1, 'blank', [0,1], 'toxic');
      addTile(1, 'fertile', []);
      addTile(2, 'fertile', [0]);
      addTile(1, 'fertile', [0,2]);
      addTile(1, 'fertile', [0,3]);
      addTile(1, 'mountain', [], null, 15);
      addTile(1, 'mountain', [], null, 20);
      addTile(1, 'mountain', [0], null, 15);
      addTile(1, 'mountain', [0], null, 20);
      addTile(1, 'mountain', [0,3], null, 20);
      addTile(4, 'riverlands', [0,3]);

      shuffleArray(tiles);
      return tiles;
      
      function addTile(qty, type, blockades, icon = null, conquestValue = 0){
        for (let i = 0; i < qty; i++){
          tiles.push({
            type: type,
            blockades: blockades,
            icon: icon,
            conquestValue: conquestValue,
          });
        }
      }
    }

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    
  </script>
</body>
</html>